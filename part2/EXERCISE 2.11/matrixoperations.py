# -*- coding: utf-8 -*-
"""Matrix-operations.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nw4XJx0_w_v7xEU8eHu0s4ILOGbBcaSx
"""

#Libraries for linear algebra
import numpy as np
import random

#HELP FUNCTIONS
def zerorow_swap(matrix1, n, m):
    
  #if diagonal value of current zero change row to first non-zero value
  for i in range(n+1, matrix1.shape[0]):
    if matrix1[i][n] != 0:
      nonzero_row = matrix1[i].copy()
      matrix1[i] = matrix1[n] 
      matrix1[n] = nonzero_row
      break;
  return matrix1

def matrix_median(matrix):
    """ finds median value in the matrix"""
    empty_list = []
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            empty_list.append(matrix[i][j]) # converts from np.array with vectors to the list
    empty_list.sort()   # sort the list   
    length = len(empty_list)
    # if the length of the list is even finds the average between two middle values
    if length % 2 == 0: 
        median = (empty_list[int((length-1)/2)] + empty_list[int((length)/2)]) / 2
    # if the length is odd, takes the middle value 
    else: 
        median = empty_list[int((length-1)/2)]

    return median

"""## Generic matrix class (rectangular)"""

class sMatrix:

  def __init__(self, rows, cols, fillvalue = 0, inputMatrix = None):
    if inputMatrix is not None:
      self.values = inputMatrix
      self.shape = inputMatrix.shape
      self.n_rows = self.shape[0]
      self.n_cols = self.shape[1]
    else:
      self.values =  np.array([[fillvalue for j in range(cols)] for i in range(rows)]) #creates matrix with inputvalue
      self.shape = self.values.shape
      self.n_rows = self.shape[0]
      self.n_cols = self.shape[1]


  def __str__(self):
    return "Matrix with {0} rows and {1} columns: \n{2}".format(self.n_rows, self.n_cols, self.values)


  def update_matrix_features(self):
    self.n_rows, self.n_cols, self.shape = self.values.shape[0], self.values.shape[1], self.values.shape


  def matrix_addition(self, matrix2):
      """ takes two matrices and return sum of these matrices"""
      #check that the dimensions of matrices are the same
      if self.shape == matrix2.shape: 
        added_matrix = np.array([[self.values[i][j] + matrix2.values[i][j] for j in range(self.n_cols)] for i in range(self.n_rows)])
        self.values = added_matrix
        return added_matrix
      else:
        print("The dimensions of matrices should be the same")

  def matrix_subtraction(self, matrix2):
    """ takes two arrays of same shape and subtracts first matrix by the second matrix"""
    #check that the dimensions of matrices are the same
    if self.shape != matrix2.shape:
      print("Input matrices should have the same dimension. Matrix1 has shape {0} and matrix2 has shape {1}.".format(matrix1.shape, matrix2.shape))
    else:
      subtracted_matrix = np.array([[self.values[i][j] - matrix2.values[i][j] for j in range(self.n_cols)] for i in range(self.n_rows)]) 
      self.values = subtracted_matrix

    return subtracted_matrix

  #dot product (vector-vector multiplication) 
  def matrix_dot_product(self, vector2):
    """ takes two vectors of same size and returns the sum of element-wise product"""
    if not (isinstance(self, np.ndarray) or isinstance(self.values, np.ndarray)):
      print('input arguments are not numpy vectors')
    elif self.values.size != vector2.values.size:
      print('length of input vectors does not match')
    else:
      return int(sum([self.values[i] * vector2.values[0][i] for i in range(self.n_rows)]))

  #matrix multiplication
  def matrix_multiplication(self, element):
    """ multiplies a matrix by another matrix if the number of columns of the matrix is the same as number of rows in the second one"""
    if self.n_cols == element.n_rows:
        multiplication = np.array([[sum(self.values[i][l] * element.values[l][j] for l in range(element.n_rows)) for j in range(element.n_cols)] for i in range(self.n_rows)])
        self.values = multiplication
        self.update_matrix_features()
        return multiplication
    else:
        print("Number of columns of the first matrix is not equal to number of rows of the second matrix")


  def matrix_scalar(self, element):
    """ multiplies each element of the matrix by a number """
    multiplication = np.array([[self.values[i][j] * element for j in range(self.n_cols)] for i in range(self.n_rows)])
    self.values = multiplication
    self.update_matrix_features()
    return multiplication


  def matrix_transpose(self):
    """takes a matrix and returns a matrix with flipped columns and rows"""
    transposed_matrix = np.array([[self.values[j][i] for j in range(self.n_rows)] for i in range(self.n_cols)])
    self.values = transposed_matrix
    self.update_matrix_features()
      
    return transposed_matrix


  def matrix_flip_diagonal(self):
    """ takes a numpy array and returns a diagonally flipped numpy array """
    flipped_matrix = np.array(list(zip(*self.values)))
    self.values = flipped_matrix
    self.update_matrix_features()
    
    return flipped_matrix


  def matrix_flip_vertical(self):
    """ takes a numpy array and returns a vertically flipped/mirrored numpy array """
    flipped_matrix = np.copy(self.values)
    for idx, row in enumerate(self.values):
      flipped_matrix[idx] = row[::-1] #reverses order of elements in each subarray
    self.values = flipped_matrix
    self.update_matrix_features()
    
    return flipped_matrix


  def matrix_flip_horizontal(self):
    """ takes a numpy array and returns a horizontal flipped numpy array """
    flipped_matrix = self.values[::-1] #reverses the order of the rows
    self.values = flipped_matrix
    self.update_matrix_features()
    
    return flipped_matrix


  def matrix_rotate(self, times = 1): 
    """ takes a numpy array matrix and rotates matrix clockwise so many times as it is specified. 
    One rotation is set as default"""
    rotated_matrix = self.values
    while times > 0:
        rotated_matrix = self.matrix_flip_horizontal()
        rotated_matrix = self.matrix_transpose()
        self.values = rotated_matrix
        self.update_matrix_features()
        times -= 1
        
    return rotated_matrix


  def matrix_back_rotate(self, times = 1):  
    """ takes a numpy array matrix and rotates matrix counterclockwise so many times as it is specified
    One rotation is set as default"""
    rotated_matrix = self.values
    while times > 0:
        rotated_matrix = self.matrix_flip_vertical()
        rotated_matrix = self.matrix_transpose()
        self.values = rotated_matrix
        self.update_matrix_features()
        times -= 1
        
    return rotated_matrix
  

  def matrix_crop(self, rows, columns, crop_type = "central"):
    """takes a matrix and returns a reduced matrix depends on the type.
    Central type: crops the matrix from the center
    Leftup type: crops the matrix from left up corner
    Leftdown type: crops the matrix from left down corner
    Rightuo type : crops the matrix from right up corner
    Rightdown type: crops the matrix from right down corner """
    if crop_type == "central":
        if self.n_rows % 2 == 0:
            matrix = self.values[int(self.n_rows/2) - int(rows/2) : int(self.n_rows/2) + int(rows/2), int(self.n_cols/2) - int(columns/2) : int(self.n_cols/2) + int(columns/2)]
        else:
            matrix = self.values[int(self.n_rows/2) - int(rows/2) : int(self.n_rows/2) + int(1 + rows/2), int(self.n_cols/2) - int(columns/2): int(self.n_cols/2) + int(1 + columns/2)]
    elif crop_type == "leftup":
        matrix = self.values[: rows, : columns]
    elif crop_type == "leftdown":
        matrix = self.values[-rows : , : columns]
    elif crop_type == "rightup":
        matrix = self.values[ : rows, -columns : ]
    elif crop_type == "rightdown":
        matrix = self.values[-rows : , -columns : ]
        
    return matrix 


  def matrix_echelon(self):
    """ Takes a matrix and reduces it to the Echelon form. Returns its echelon 
    matrix and a counter that keeps track of row swaps"""
    
    temp_matrix = self.values.astype(float)
    row_swap_counter = 0

    for n in range(temp_matrix.shape[1]):
      for m in range(n+1, temp_matrix.shape[0]): 
            
        if temp_matrix[n][n] == 0.0:
          temp_matrix = zerorow_swap(temp_matrix, n, m)
          row_swap_counter += 1


        factor1, factor2 = temp_matrix[m][n], temp_matrix[n][n]
        temp_matrix[m] -= (temp_matrix[n] * factor1/factor2)
    
    echelon_matrix = temp_matrix
      
    return echelon_matrix, row_swap_counter


  def matrix_reduced_echelon(self):
    """ Takes a matrix and reduces it to the Echelon form. Returns its echelon 
    matrix and a counter that keeps track of row swaps"""
    
    temp_matrix = self.values.astype(float)
    row_swap_counter = 0

    for n in range(temp_matrix.shape[1]):
      for m in range(n+1, temp_matrix.shape[0]): 
            
        if temp_matrix[n][n] == 0.0:
          temp_matrix = zerorow_swap(temp_matrix, n, m)
          row_swap_counter += 1


        factor1, factor2 = temp_matrix[m][n], temp_matrix[n][n]
        temp_matrix[m] -= (temp_matrix[n] * factor1/factor2)
    
    echelon_matrix = temp_matrix
      
    return echelon_matrix, row_swap_counter



  def minor_matrix(self, row, column):
    """ returns a matrix without assigned row or column"""
    matrix = self.__class__(self.shape[0]-1, self.shape[1]-1)
  
    for i in range(self.shape[0]):
        for j in range(self.shape[1]):
            if i < row:
                if j < column:
                    matrix.values[i][j] = self.values[i][j]
                elif j > column:
                    matrix.values[i][j-1] = self.values[i][j]         
                
            elif i > row:
                if j < column:
                    matrix.values[i-1][j] = self.values[i][j]
                elif j > column:
                    matrix.values[i-1][j-1] = self.values[i][j]
                                   
    return matrix

  def median_filter(self): 
      """ takes a matrix as input and replaces central value with median for each matrix of 3x3 sizes, excluding border values 
      Uses helper function matrix_median """
      matrix = self.__class__(self.shape[0], self.shape[1], inputMatrix = self.values)
      for i in range(self.n_rows):
          for j in range(self.n_cols):
            # excludes border values from smoothing 
            if i == 0 or i == (self.n_rows-1) or j == 0 or j == (self.n_cols-1):
                continue
            else:
                # replaces the value with the median value from the matrix of adjusted values
                matrix.values[i][j] = matrix_median(matrix.values[i-1 : i+2, j-1 : j+2])  

      return matrix



"""## Class for square matrices"""

class sSquareMatrix(sMatrix):
  """ Implemented class for square matrices of dimensions nxn """

  def __init__(self, rows, fillvalue = 0, inputMatrix = None):
    if inputMatrix is not None:
      self.values = inputMatrix
      self.shape = inputMatrix.shape
      self.n_rows = self.shape[0]
      self.n_cols = self.shape[1]
    else:
      self.values =  np.array([[fillvalue for j in range(rows)] for i in range(rows)]) #creates matrix with inputvalue
      self.shape = self.values.shape
      self.n_rows = self.shape[0]
      self.n_cols = self.shape[1]

  def matrix_det(self):
    """ Takes a single squared matrix and returns the determinant of the matrice 
    by multiplying value from the main diagonal of the reduced echelon form"""
    determinant = 1
    if self.n_rows == 2:
      determinant = self.values[0][0] * self.values[1][1] - self.values[1][0] * self.values[0][1]
    else: 
      reduced_matrix, n_swaps = sMatrix.matrix_echelon(self) #gets echelon form from SMatrix class
 
      for i in range(reduced_matrix.shape[1]): #takes values from main diagonal
        determinant *= reduced_matrix[i][i]

      determinant = determinant * (-1)**n_swaps

    return determinant


  def matrix_inverse(self):
    """ inverses a Matrix using Minors, Cofactors and Adjugate"""
    matrix = self.__class__(self.n_rows)

    # Step 1. checks that the determinant is not equal to 0
    if sSquareMatrix.matrix_det(self) != 0:
    
      # Step 2. determines matrix of Cofactors
      for i in range(self.n_rows):
        for j in range(self.n_cols):
          cropted_matrix = sMatrix.minor_matrix(self, i, j)

          #finds a matrix of minors and transform it into matrix of cofactors Cij = (−1)^(i+j) * Mij
          matrix.values[i][j] = sSquareMatrix.matrix_det(cropted_matrix)
          
          matrix.values[i][j] = matrix.values[i][j] * ((-1)**(i+1+j+1))
      
      # Step 3. The transpose of the matrix 
      matrix.values = sMatrix.matrix_transpose(matrix)
      
      # Step 4. Multiply by 1/Determinant
      matrix.values = sMatrix.matrix_scalar(matrix, float(1/sSquareMatrix.matrix_det(self))) 
            
      return matrix.values
    else:
      print("The determinant cannot be equalt to 0")

"""## Class for identity matrices"""

#inherit sMatrix
class sIdentityMatrix(sSquareMatrix):
  """ """

  def __init__(self, n_rows):
    self.values = np.array([[0 for j in range(n_rows)] for i in range(n_rows)]) #creates matrix with inputvalue
    self.shape = self.values.shape
    self.n_rows = self.shape[0]
    self.n_cols = self.shape[1]
    for i in range(n_rows): 
      self.values[i][i] = 1
  
  
  def matrix_inverse(matrix1):
    """ The inverse of an identity matrix is itself."""
    return matrix1.values